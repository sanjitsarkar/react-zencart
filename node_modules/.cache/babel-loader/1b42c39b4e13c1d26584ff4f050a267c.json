{"ast":null,"code":"import { v4 as uuid } from 'uuid';\nimport { Response } from 'miragejs';\nimport { formatDate } from '../utils/authUtils';\nimport bcrypt from 'bcryptjs';\n\nconst jwt = require('jsonwebtoken');\n/**\n * All the routes related to Auth are present here.\n * These are Publicly accessible routes.\n * */\n\n/**\n * This handler handles user signups.\n * send POST Request at /api/auth/signup\n * body contains {firstName, lastName, email, password}\n * */\n\n\nexport const signupHandler = function (schema, request) {\n  const {\n    email,\n    password,\n    ...rest\n  } = JSON.parse(request.requestBody);\n\n  try {\n    // check if email already exists\n    const foundUser = schema.users.findBy({\n      email\n    });\n\n    if (foundUser) {\n      return new Response(422, {}, {\n        errors: ['Unprocessable Entity. Email Already Exists.']\n      });\n    }\n\n    const _id = uuid();\n\n    const encryptedPassword = bcrypt.hashSync(password, 5);\n    const newUser = {\n      _id,\n      email,\n      password: encryptedPassword,\n      createdAt: formatDate(),\n      updatedAt: formatDate(),\n      ...rest,\n      cart: [],\n      wishlist: []\n    };\n    const createdUser = schema.users.create(newUser);\n    const encodedToken = jwt.sign({\n      _id,\n      email\n    }, process.env.REACT_APP_JWT_SECRET);\n    return new Response(201, {}, {\n      createdUser,\n      encodedToken\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};\n/**\n * This handler handles user login.\n * send POST Request at /api/auth/login\n * body contains {email, password}\n * */\n\nexport const loginHandler = function (schema, request) {\n  const {\n    email,\n    password\n  } = JSON.parse(request.requestBody);\n\n  try {\n    const foundUser = schema.users.findBy({\n      email\n    });\n\n    if (!foundUser) {\n      return new Response(404, {}, {\n        errors: ['The email you entered is not Registered. Not Found error']\n      });\n    }\n\n    if (bcrypt.compareSync(password, foundUser.password)) {\n      const encodedToken = jwt.sign({\n        _id: foundUser._id,\n        email\n      }, process.env.REACT_APP_JWT_SECRET);\n      foundUser.password = undefined;\n      return new Response(200, {}, {\n        foundUser,\n        encodedToken\n      });\n    }\n\n    return new Response(401, {}, {\n      errors: ['The credentials you entered are invalid. Unauthorized access error.']\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};","map":{"version":3,"sources":["/home/xanjit/Desktop/neog/react/react-zencart/src/backend/controllers/AuthController.js"],"names":["v4","uuid","Response","formatDate","bcrypt","jwt","require","signupHandler","schema","request","email","password","rest","JSON","parse","requestBody","foundUser","users","findBy","errors","_id","encryptedPassword","hashSync","newUser","createdAt","updatedAt","cart","wishlist","createdUser","create","encodedToken","sign","process","env","REACT_APP_JWT_SECRET","error","loginHandler","compareSync","undefined"],"mappings":"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","sourcesContent":["import { v4 as uuid } from 'uuid';\nimport { Response } from 'miragejs';\nimport { formatDate } from '../utils/authUtils';\nimport bcrypt from 'bcryptjs';\nconst jwt = require('jsonwebtoken');\n\n/**\n * All the routes related to Auth are present here.\n * These are Publicly accessible routes.\n * */\n\n/**\n * This handler handles user signups.\n * send POST Request at /api/auth/signup\n * body contains {firstName, lastName, email, password}\n * */\n\nexport const signupHandler = function (schema, request) {\n\tconst { email, password, ...rest } = JSON.parse(request.requestBody);\n\ttry {\n\t\t// check if email already exists\n\t\tconst foundUser = schema.users.findBy({ email });\n\t\tif (foundUser) {\n\t\t\treturn new Response(\n\t\t\t\t422,\n\t\t\t\t{},\n\t\t\t\t{\n\t\t\t\t\terrors: ['Unprocessable Entity. Email Already Exists.'],\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\tconst _id = uuid();\n\t\tconst encryptedPassword = bcrypt.hashSync(password, 5);\n\t\tconst newUser = {\n\t\t\t_id,\n\t\t\temail,\n\t\t\tpassword: encryptedPassword,\n\t\t\tcreatedAt: formatDate(),\n\t\t\tupdatedAt: formatDate(),\n\t\t\t...rest,\n\t\t\tcart: [],\n\t\t\twishlist: [],\n\t\t};\n\t\tconst createdUser = schema.users.create(newUser);\n\t\tconst encodedToken = jwt.sign({ _id, email }, process.env.REACT_APP_JWT_SECRET);\n\t\treturn new Response(201, {}, { createdUser, encodedToken });\n\t} catch (error) {\n\t\treturn new Response(\n\t\t\t500,\n\t\t\t{},\n\t\t\t{\n\t\t\t\terror,\n\t\t\t},\n\t\t);\n\t}\n};\n\n/**\n * This handler handles user login.\n * send POST Request at /api/auth/login\n * body contains {email, password}\n * */\n\nexport const loginHandler = function (schema, request) {\n\tconst { email, password } = JSON.parse(request.requestBody);\n\ttry {\n\t\tconst foundUser = schema.users.findBy({ email });\n\t\tif (!foundUser) {\n\t\t\treturn new Response(404, {}, { errors: ['The email you entered is not Registered. Not Found error'] });\n\t\t}\n\t\tif (bcrypt.compareSync(password, foundUser.password)) {\n\t\t\tconst encodedToken = jwt.sign({ _id: foundUser._id, email }, process.env.REACT_APP_JWT_SECRET);\n\t\t\tfoundUser.password = undefined;\n\t\t\treturn new Response(200, {}, { foundUser, encodedToken });\n\t\t}\n\t\treturn new Response(\n\t\t\t401,\n\t\t\t{},\n\t\t\t{\n\t\t\t\terrors: ['The credentials you entered are invalid. Unauthorized access error.'],\n\t\t\t},\n\t\t);\n\t} catch (error) {\n\t\treturn new Response(\n\t\t\t500,\n\t\t\t{},\n\t\t\t{\n\t\t\t\terror,\n\t\t\t},\n\t\t);\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}